---
title: "Are environmental and geographic effective surrogates for genetic variation in conservation planning?"
author: |
  | Jeffrey O. Hanson$^1$, Jonathan R. Rhodes$^2$, Cynthia Riginos$^2$, Hugh P. Possingham$^1$, Richard A. Fuller$^1$
  | $^1$School of Biological Sciences, The University of Queensland, Brisbane, QLD, Australia
  | $^2$School of Geography, Planning and Environmental Management, The University of Queensland, Brisbane, QLD, Australia
  | Correspondance should be addressed to jeffrey.hanson@uqconnect.edu.au
date: "`r format(Sys.time(), '%d %B %Y')`"
tags: ["conservation", "biodiversity", "AFLP", "reserve-selection"]
abstract: "Insert abstract here."
output:
  rmarkdown::pdf_document:
    toc: true
    toc_depth: 5
    keep_tex: yes
    fig_caption: yes
    includes:
      in_header: preamble-latex.tex
fontsize: 11pt
documentclass: article
bibliography: Endnote_lib.bib
csl: reference-style.csl
vignette: >
  %\VignetteIndexEntry{rapr}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, include=FALSE}
# set global cache
knitr::opts_chunk$set(cache=TRUE)

# load packages
library(genetic.surrogates)
library(data.table)
library(rgeos)
library(ggplot2)
library(grid)
library(gridExtra)
library(plotrix)
library(plyr)
library(dplyr)
library(tidyr)
library(pander)
library(multcomp)

# set pander options
panderOptions('knitr.auto.asis', FALSE)

# set default select method
select <- dplyr::select

### set parameters
## debugging parameters
# number of species
n.spp <- 3
# BayeScan parameters
bs.threshold <- 0.5
bs.threads <- 1
bs.n <- 50
bs.thin <- 1
bs.nbp <- 10
bs.pilot <- 50
bs.burn <- 10
# MDS parameters
mds.k <- 2
mds.trymax <- 2
# Gurobi parameters
gb.Threads <- 1L
gb.MIPGap <- 0.9
# targets
rapr.amount.target <- 0.2
rapr.surrogate.target <- 0.9
rapr.genetic.target <- 0.9
rapr.pareto.surrogate.targets <- seq(0.01, 1, length.out=3)

## analysis parameters
## number of species
## n.spp <- 27
## BayeScan parameters
# bs.threshold <- 0.95
# bs.threads <- 10
# bs.n <- 5000
# bs.thin <- 10
# bs.nbp <- 20
# bs.pilot <- 50000
# bs.burn <- 50000
# MDS parameters
# mds.k <- 2
# mds.trymax <- 100
## Gurobi parameters
# gb.Threads <- 10
# gb.MIPGap <- 0.05

# set seed for reproducibility
set.seed(500)
```
 
## Introduction


## Methods
### Study area
To address the aims of this study, we utilized species distribution and genomic data collected by the IntraBioDiv project [@r452]. As part of this project, data for 27 Alpine plant species were collected across the European Alps using a regular grid (22.3 km \times 25 km; see @452 for methodological details). In every second cell, plant samples were collected from three individiduals for each species present inside the cell . Samples were genotyped using amplified fragment length polymorphisms (AFLP; r453). Matrices denoting the presence/absence of polymorphisms at loci were consutrcted independently for each species. This dataset was ideal for our purposes, because it contains genomic data for a multitude of species collected at a high spatial resolution. Additionally, the data were collected across broad-scale environmental gradients that are suitable for exploring broad-scale surrogates for genetic variation.

```{r, include=FALSE}
## compile spatial grid data
# load grid cell centroids
grid.DF <- fread(
	'extdata/Data_Meirmans_et_al_IntrabioDiv/ReadMe.txt',
	data.table=FALSE,
	skip='cell\tLong\tLat'
) %>% rename(
		grid.longitude=Long,
		grid.latitude=Lat
) %>% mutate(
	id=seq_along(grid.latitude)
)
```

```{r, include=FALSE}
# load in aflp data
spp.aflp.paths <- dir(
	'extdata/Data_Meirmans_et_al_IntrabioDiv',
	'^.*AFLP\\.dat$',
	full.names=TRUE
)[seq_len(n.spp)]
spp.BayeScanData.LST <- llply(
	spp.aflp.paths,
	read.BayeScanData
)
```

```{r, include=FALSE}
## compile species occurence data
# load in data
spp.loc.paths <- dir(
	'extdata/Data_Meirmans_et_al_IntrabioDiv',
	'^.*locations\\.txt$',
	full.names=TRUE
)[seq_len(n.spp)]
spp.samples.DF <- ldply(
	seq_along(spp.loc.paths),
	.fun=function(i) {
		x <- mutate(
			fread(spp.loc.paths[i], data.table=FALSE),
			species=gsub('_locations.txt', '', basename(spp.loc.paths[i]), fixed=TRUE)
		) %>% rename(
			cell=population,
			sample.longitude=longitude,
			sample.latitude=latitude
		)
		return(x[as.numeric(spp.BayeScanData.LST[[i]]@populations),])
	}
) %>% left_join(
		grid.DF,
		by='cell'
)
# append species data to grid data.frame (wide-format)
for (i in unique(spp.samples.DF$species))
	grid.DF[[i]] <- replace(
		rep(0, nrow(grid.DF)),
		which(grid.DF$cell %in% filter(spp.samples.DF, species==i)$cell),
		1
	)
```

### Surrogate data
We used explored the effectiveness of environmental and geographic surrogates. To describe variation in the location of each grid, we projected the grids to ESRI:XXXX and calculated the centroid of each cell. To describe the climatic variation among each cell, we obtained 21 bioclimatic variables (Hijmans et al. XXXX). These layers were clipped to the extent of the grid, and layers were subject to a principle components analysis. The first two principle components were used to generate two new layers that described broad-scale climatic variation among the layers. The average value of each PC component in each grid was used to characterise a different dimension of climatic variation in the grid cell.

```{r, include=FALSE}
## create spatial data
# grid data as SpatialPolygonsDataFrame
grid.PTS <- SpatialPoints(as.matrix(grid.DF[,2:3]))
grid.PLY <- grid.PTS %>%
	points2grid(tolerance=0.05) %>%
	as('SpatialPolygons')
grid.PLY <- grid.PLY[sapply(gIntersects(grid.PTS, grid.PLY, byid=TRUE, returnDense=FALSE), `[[`, 1),] %>%
	spChFIDs(
		as.character(seq_len(nrow(grid.DF)))
	) %>% 
	SpatialPolygonsDataFrame(
		data=grid.DF
	)
grid.PLY@proj4string <- wgs1984
grid.PPLY <- spTransform(grid.PLY, europeEA)
# sample data as SpatialPoints
spp.sample.PTS <- SpatialPointsDataFrame(
	coords=as.matrix(spp.samples.DF[,5:6]),
	data=spp.samples.DF,
	proj4string=wgs1984
)
spp.sample.PPTS <- spTransform(spp.sample.PTS, europeEA)
## extract geographic data
centroids.DF <- gCentroid(grid.PPLY, byid=TRUE) %>% slot('coords') %>%
	as.data.frame() %>% `names<-`(paste0('geo_d',1:2))
grid.DF <- cbind(grid.DF, centroids.DF)
## extract climatic data
# load climatic data
bioclim.STK <- stack('extdata/BioClim_variables/bioclim_pca.tif')
# extract mean for each cell for each principle component
extract.DF <- grid.PPLY %>% rasterize(bioclim.STK, field='id') %>% 
	zonal(x=bioclim.STK) %>% as.data.frame() %>% select(-1) %>%
	`names<-`(paste0('env_d',seq_len(nlayers(bioclim.STK))))
# merge with grid.DF
grid.DF <- cbind(grid.DF, extract.DF)
## update spatial objects
grid.PLY@data <- grid.DF
grid.PPLY@data <- grid.DF
```

### Outlier locus detection
The environmental and geographic surrogates are expected to have different levels of effectiveness for adaptive and neutral genetic variation. To investigate the effectiveness of these surrogates, we identified the loci under selection for each species. We used outlier locus detection methods [reviewed in @r453] to avoid circularity issues. The basic premise underpinning these methods is that neutral loci are expected to have a specific level of variation among populations ($F_{st}$), and loci that deviate from this expectation are under selection. Previously, XXXX _et al._ (XXXX) utilised this dataset and applied such detection methods to _Getiana nivalis_. Here, we applied their methods to each of the 27 species in the dataset. 

Breifly, we grouped individuals into genetic lineages (Figure XXX). The purposes of this step was to avoid confounding effects of genetic history between populations when identifying loci under selection. We used the Bayesian clustering method implemented in STRUCTURE (version XXXX) assuming admixture and an independent alleles model. For each species, we identified the most plausible number of populations (K = 1--10; five replicates for each K; model with lowest mean posterior negative log likelihood), and estimated the probability that each individual belonged to each population (200,000 burn-in; 1,000,000 iterations). Individuals with $\geq 0.75$ probability of belonging to a single population were assigned accordingly, and used for subsequent analysis (see Appendix XXX for STRUCTURE results for each species).

We used BAYESCAN [@rXX] to identify loci under selection for each species (Figure XXX). For each species, BAYESCAN was run using the population memberships identied in the STRUCTURE analysis (using 1:1 prior odds, `r bs.nbp` pilot runs, and `r bs.n` iterations thinned by `r bs.thin` iterations with a `bs.burn` burn-in). Following recomendations in the BAYESCAN manual, we omitted loci where the global frequency of the minor allele was <0.05 to avoid false-positives. To ensure convergence of results, we ran four replicates of BAYESCAN per species using a false discovery rate (FDR) < 0.1 (see Appendix XXX for BAYESCAN results for each species). 

After classifying the loci as adaptive or neutral for each species, we used non-metric multi-dimensional scaling (NMDS) to derive new variables to describe the main themes of variation in the adaptive and/or neutral loci for each species. Specifically, we calculated Gower distances between the adaptive and/or neutral polymorphisms using the cluster R package (XXXX) to accomodate missing data. These distance matrices were then subject to XXXX as implemented in the vegan R package (XXX; K=2, 100 runs). The resulting ordinations were then associated with the grid cells such that each grid cell where as species was detected with individuals that were assigned to a population was associated a coordinate in adaptive and neutral space.

```{r, include=FALSE}
# assign cells as populations
spp.BayeScanData.LST <- llply(
	seq_along(unique(spp.samples.DF$species)),
	function(i) {
		bd <- spp.BayeScanData.LST[[i]]
		bd@populations <- filter(spp.samples.DF, species==unique(spp.samples.DF$species)[i])$cell
		return(bd)
	}
)
# run BayeScan
spp.BayeScan.LST <- llply(
	spp.BayeScanData.LST,
	run.BayeScan,
	threshold=bs.threshold,
	threads=bs.threads,
	n=bs.n,
	thin=bs.thin,
	nbp=bs.nbp,
	pilot=bs.pilot,
	burn=bs.burn
)
# run MDS
spp.mds.LST <- llply(
	spp.BayeScan.LST,
	function(i) {
		`names<-`(llply(c('adaptive', 'neutral'), function(j) {
			if (sum(i@results@fst==j)==0)
				return(NULL)
			return(
				mds(
					i,
					metric='gower',
					type=j,
					k=mds.k,
					trymax=mds.trymax
				)
			)
		}), c('adaptive','neutral'))
	}
)
# store mds rotations for each sample
spp.samples.DF <- ldply(seq_along(unique(spp.samples.DF$species)), .fun=function(i) {
	x <- filter(spp.samples.DF, species==unique(spp.samples.DF$species)[i])
	for (j in c('adaptive', 'neutral')) {
		if (!is.null(spp.mds.LST[[i]][[j]])) {
			x <- cbind(
				x,
				`names<-`(
					as.data.frame(spp.mds.LST[[i]][[j]]$points),
					paste0(j,'_d',seq_len(mds.k))
				)
			)
		}
	}
	return(x)
})
# store mds average rotation for each grid
for (i in seq_along(unique(spp.samples.DF$species))) {
	for (j in c('adaptive', 'neutral')) {
		if(!is.null(spp.mds.LST[[i]][[j]])) {
			curr.sub <- filter(spp.samples.DF, species==unique(spp.samples.DF$species)[i])
			for (k in seq_len(mds.k)) {
				curr.vals <- tapply(
					curr.sub[[paste0(j,'_d',k)]],
					curr.sub$cell,
					FUN=mean
				)
				curr.pos <- match(names(curr.vals), grid.DF$cell)
				grid.DF[curr.pos,paste0(unique(spp.samples.DF$species)[i],'_',j,'_d',k)] <- curr.vals
			}
		}
	}
}
```

### Prioritisations

```{r, include=FALSE}
# generate attribute spaces for geographic and environmental data
surrogate.ASL <- llply(
	list(grep('^env.*$', names(grid.DF)),grep('^geo.*$', names(grid.DF))),
	.fun=function(x) {
		make.multi.species.AttributeSpace(
			site.data=grid.DF[,x,drop=FALSE],
			species.data=grid.DF[,unique(spp.samples.DF$species),drop=FALSE]
		)
	}
)
# generate attribute spaces for genetic data
adaptive.ASL <- llply(
	seq_along(unique(spp.samples.DF$species)),
	function(i) {
		make.single.species.AttributeSpace(
			site.data=select(grid.DF, contains(paste0(unique(spp.samples.DF$species)[i], '_adaptive'))),
			species.data=select(filter(spp.samples.DF, species==unique(spp.samples.DF$species)[i]), contains('adaptive')),
			spp.pos=i,
			n.species=n_distinct(spp.samples.DF$species)
		)
	}
)
neutral.ASL <- llply(
	seq_along(unique(spp.samples.DF$species)),
	function(i) {
		make.single.species.AttributeSpace(
			site.data=select(grid.DF, contains(paste0(unique(spp.samples.DF$species)[i], '_neutral'))),
			species.data=select(filter(spp.samples.DF, species==unique(spp.samples.DF$species)[i]), contains('neutral')),
			spp.pos=i,
			n.species=n_distinct(spp.samples.DF$species)
		)
	}
)
# make table with targets
target.DF <- make.targets(
	species=unique(spp.samples.DF$species),
	environmental.space=as1[[1]], geographic.space=as1[[2]],
	adaptive.spaces=adaptive.ASL, neutral.spaces=neutral.ASL,
	amount.target=0.2, space.target=0.2
)
# make Rap objects
rd <- RapData(
	polygon=SpatialPolygons2PolySet(grid.PLY),
	pu=data.frame(
		cost=rep(1, nrow(grid.DF)),
		area=rep(1, nrow(grid.DF)),
		status=rep(0L, nrow(grid.DF))
	),
	species=data.frame(name=unique(spp.samples.DF$species)),
	target=target.DF,
	attribute.spaces=append(append(surrogate.ASL, adaptive.ASL), neutral.ASL),
	pu.species.probabilities=ldply(
		seq_along(unique(spp.samples.DF$species)),
		.fun=function(i) {
			data.frame(
				species=i,
				pu=which(grid.DF[[unique(spp.samples.DF$species)[i]]]==1),
				value=1
			)
		}
	),
	boundary=calcBoundaryData(grid.PLY)
)
ru <- RapUnsolved(RapUnreliableOpts(), rd)
```

```{r, include=FALSE}
## single species analysis
# generate RapSolved objects
single.spp.prioritisations <- llply(
	seq_along(unique(spp.samples.DF$species)),
	function(x) {
		llply(
			list(
				c(rapr.amount.target,0,0), c(rapr.amount.target,rapr.surrogate.target,0), 
					c(rapr.amount.target,0,rapr.genetic.target,0)
			), 
			function(y) {
				species.prioritisation(
					x=spp.subset(ru, x),
					amount.targets=y[1],
					env.surrogate.targets=y[2],
					geo.surrogate.targets=y[2],
					adaptive.genetic.targets=y[3],
					neutral.genetic.targets=y[3],
					Threads=gb.Threads,
					MIPGap=gb.MIPGap
				)
			}
		)
	}
)
# generate results table
single.spp.DF <- ldply(
	single.spp.prioritisations,
	function(x) {
		mutate(
			ldply(x, extractResults),
			Prioritisation=c('Amount', 'Surrogate', 'Genetic')
		)
	}
)
```

```{r, include=FALSE}
## multispecies analysis
# make prioritisations
multi.spp.prioritisations <- llply(
	list(
		c(rapr.amount.target,0,0), c(rapr.amount.target,rapr.surrogate.target,0), 
			c(rapr.amount.target,0,rapr.genetic.target,0)
	), 
	function(y) {
		species.prioritisation(
			x=ru,
			amount.targets=y[1],
			env.surrogate.targets=y[2],
			geo.surrogate.targets=y[2],
			adaptive.genetic.targets=y[3],
			neutral.genetic.targets=y[3],
			Threads=gb.Threads,
			MIPGap=gb.MIPGap
		)
	}
)
# generate results table
multi.spp.DF <- ldply(seq_along(multi.spp.prioritisations), function(i) {
	mutate(
		extractResults(multi.spp.prioritisations[[i]]),
		Prioritisation=c('Amount', 'Surrogate', 'Genetic')[i]
	)
})
```

```{r, include=FALSE}
## pareto frontier analysis
# generate prioritistions
env.pareto.prioritisations <- llply(
	rapr.pareto.surrogate.targets,
	species.prioritisation,
	x=ru,
	amount.targets=0,
	geo.surrogate.targets=0,
	adaptive.genetic.targets=0,
	neutral.genetic.targets=0
)
geo.pareto.prioritisations <- llply(
	rapr.pareto.surrogate.targets,
	species.prioritisation,
	x=ru,
	amount.targets=0,
	env.surrogate.targets=0,
	adaptive.genetic.targets=0,
	neutral.genetic.targets=0
)
# extract results
env.pareto.DF <- ldply(seq_along(env.pareto.prioritisations), function(i) {
	mutate(
		extractResults(env.pareto.prioritisations[[i]]),
		Surrogate.target=rapr.pareto.surrogate.targets[i]
	)
})
geo.pareto.DF <- ldply(seq_along(geo.pareto.prioritisations), function(i) {
	mutate(
		extractResults(geo.pareto.prioritisations[[i]]),
		Surrogate.target=rapr.pareto.surrogate.targets[i]
	)
})
```

## Results
### Single species prioritisations
```{r}
## statistical analysis
# prepare data
single.spp.SDF <- single.spp.DF %>%
	gather(Metric, value, amount.held:neutral.held) %>%
	filter(Metric %in% c('adaptive.held', 'neutral.held')) %>%
	mutate(Metric=revalue(Metric, c('adaptive.held'='Adaptive variation', 
		'neutral.held'='Neutral variation'))) %>%
	mutate(Prioritisation.Metric=interaction(Prioritisation,Metric)) 
# model
single.spp.GLM <- suppressWarnings(glm(value ~ Prioritisation * Metric,
	family='binomial', data=single.spp.SDF))
single.spp.AOV <- suppressWarnings(anova(single.spp.GLM))
# post-hoc
single.spp.GLM2 <- suppressWarnings(glm(value ~ Prioritisation.Metric,
	family='binomial', data=single.spp.SDF))
single.spp.MCP <- summary(
	glht(single.spp.GLM2,
		linfct=mcp(Prioritisation.Metric='Tukey')),
	adjusted('bonferroni'))
```



```{r, fig.width=6, fig.height=3, fig.cap='Summary of single species prioritisations. Single species prioritisations were generated using amount-based targets, amount-based and surrogate-based targets, and amount-based and genetic-based targets for each species. Data shows the performance of prioritisations generated using these three sets of targets. Bars denote means and standard errors.'}
# prepare data for plotting
single.spp.PDF <- expand.grid(
	Prioritisation=unique(single.spp.SDF$Prioritisation),
	Metric=unique(single.spp.SDF$Metric))
single.spp.PDF <- cbind(single.spp.PDF,
	as.data.frame(predict(single.spp.GLM, single.spp.PDF,
		type='response', se.fit=TRUE))) %>%
	mutate(lower=fit-se.fit, upper=fit+se.fit,
		letters=toupper(cld(single.spp.MCP)$mcletters$Letters),
		letter_pos=upper+0.05)
# make plot
ggplot(aes(x=Metric,y=fit,fill=Prioritisation),
	data=single.spp.PDF) +
	geom_bar(position=position_dodge(0.9),
		stat='identity') +
	geom_errorbar(
		aes(ymin=lower,ymax=upper),
		position=position_dodge(0.9), width=0.6) +
	geom_text(aes(x=Metric, y=letter_pos,
		label=letters), position=position_dodge(0.9)) +
	scale_fill_manual(name='Prioritisation',
		values=c('grey80','grey50','grey20')) +
	ylab('Proportion genetic\nvariation secured (%)') +
	xlab('') +
	theme_classic()
```

### Multi-species prioritisations
```{r}
## statistical analysis
# prepare data
multi.spp.SDF <- multi.spp.DF %>%
	gather(Metric, value, amount.held:neutral.held) %>%
	filter(Metric %in% c('adaptive.held', 'neutral.held')) %>%
	mutate(Metric=revalue(Metric, c('adaptive.held'='Adaptive variation', 
		'neutral.held'='Neutral variation'))) %>%
	mutate(Prioritisation.Metric=interaction(Prioritisation,Metric)) 
# model
multi.spp.GLM <- suppressWarnings(glm(value ~ Prioritisation * Metric,
	family='binomial', data=multi.spp.SDF))
multi.spp.AOV <- suppressWarnings(anova(multi.spp.GLM))
# post-hoc
multi.spp.GLM2 <- suppressWarnings(glm(value ~ Prioritisation.Metric,
	family='binomial', data=multi.spp.SDF))
multi.spp.MCP <- summary(
	glht(multi.spp.GLM2,
		linfct=mcp(Prioritisation.Metric='Tukey')),
	adjusted('bonferroni'))
```

```{r, fig.width=8, fig.height=3.5, fig.cap='Multi-species prioritisations. Panel (a) shows the prioritisation generated for using just amount-based targets. Panel (b) shows the prioritisation generated using amount-based and surrogate based targets. Panel (c) shows the prioritisation generated using amount-based and genetic-based targets'}
# download basemap
data(countriesHigh)
countries.FPLY <- countriesHigh[
	countriesHigh$ADMIN %in% c(
		'Italy', 'Switzerland', 'France', 'Austria',
		'Germany', 'Slovenia', 'Croatia', 'Hungary',
		'Monaco', 'Germany'
	)
,] %>% spFortify
# prepare data for plotting
multi.spp.grid.FPLY <- grid.PLY
for (i in seq_along(multi.spp.prioritisations))
	multi.spp.grid.FPLY@data[[paste0('v',i)]] <- selections(multi.spp.prioritisations[[i]])
multi.spp.grid.FPLY <- spFortify(multi.spp.grid.FPLY)
# make maps
do.call(
	grid.arrange,
	append(
		llply(
			seq_along(multi.spp.prioritisations),
			function(i) {
				ggplot() +
					geom_polygon(data=countries.FPLY, aes(x=long, y=lat, group=group),
						fill='grey20', color='grey80') +
					geom_polygon(data=multi.spp.grid.FPLY, aes_string(x='long', y='lat', 
						group='group', fill=paste0('v',i)),
						alpha=0.8, color='grey10') +
					guides(fill=guide_legend(title=' ')) +
					theme_classic() +
					theme(axis.ticks=element_blank(), axis.text=element_blank(),
						plot.margin=unit(c(0,0,0,0),'cm'), axis.line=element_blank(),
						legend.position='none') +
					coord_cartesian(
						xlim=buffered.range(multi.spp.grid.FPLY$long, 0.05),
						ylim=buffered.range(multi.spp.grid.FPLY$lat, 0.05)
					) +
					xlab('') +
					ylab('') +
					annotate('text',
						x=min(multi.spp.grid.FPLY$long)+diff(range(multi.spp.grid.FPLY$long)*0.1),
						y=min(multi.spp.grid.FPLY$lat)+diff(range(multi.spp.grid.FPLY$lat)*1.01),
						label=letters[i], hjust=1, vjust=1, color='white', size=8)
			}
		),
		list(nrow=1)
	)
)
```

```{r, fig.width=6, fig.height=3, fig.cap='Summary of multi-species prioritisations. Three prioritisations were generated using amount-based targets, amount-based and surrogate-based targets, and amount-based and genetic-based targets for each species. Data shows the performance of these prioritisations based on how much genetic variation they explain. Bars denote means and standard errors.'}
# prepare data for plotting
multi.spp.PDF <- expand.grid(
	Prioritisation=unique(multi.spp.SDF$Prioritisation),
	Metric=unique(multi.spp.SDF$Metric))
multi.spp.PDF <- cbind(multi.spp.PDF,
	as.data.frame(predict(multi.spp.GLM, multi.spp.PDF,
		type='response', se.fit=TRUE))) %>%
	mutate(lower=fit-se.fit, upper=fit+se.fit,
		letters=toupper(cld(multi.spp.MCP)$mcletters$Letters),
		letter_pos=upper+0.05)
# make plot
ggplot(aes(x=Metric,y=fit,fill=Prioritisation),
	data=multi.spp.PDF) +
	geom_bar(position=position_dodge(0.9),
		stat='identity') +
	geom_errorbar(
		aes(ymin=lower,ymax=upper),
		position=position_dodge(0.9), width=0.6) +
	geom_text(aes(x=Metric, y=letter_pos,
		label=letters), position=position_dodge(0.9)) +
	scale_fill_manual(name='Prioritisation',
		values=c('grey80','grey50','grey20')) +
	ylab('Proportion genetic\nvariation secured (%)') +
	xlab('') +
	theme_classic()
```

### Pareo-frontier analysis

```{r, fig.width=8, fig.height=3.5, fig.cap='The relationship between surrogates and genetic variation secured in prioritisations.'}
# make plots
p1 <- ggplot(data=env.pareto.DF) +
	geom_line(aes(x=Surrogate.target,y=adaptive.held,group=Species),
		alpha=0.5) +
	xlab('Environmental variation secured (%)') +
	ylab('Adaptive genetic\nvariation secured (%)') +
	theme_classic()
p2 <- ggplot(data=geo.pareto.DF) +
	geom_line(aes(x=Surrogate.target,y=neutral.held,group=Species),
		alpha=0.5) +
	xlab('Geographic variation secured (%)') +
	ylab('Neutral genetic\nvariation secured (%)') +
	theme_classic()
grid.arrange(p1, p2, nrow=1)
```


## Discussion


## Acknowledgements
JOH is funded by an Australian Postgraduate Award (APA) scholarship. RAF has an Australian Research Council Future Fellowship. This work was supported by the Centre of Excellence for Environmental Decisions (CEED) and the Landscape Ecology and Conservation Group (LEC) at The University of Queensland.

## References


## Supporting Information
### Appendix S1: Species distributions

```{r, fig.width=9.5, fig.height=10, out.width='7.5in', out.height='8.5in', fig.cap='Species distributions. Squares represent planning units. For a given species, planning units that were found to be inhabited are denoted with bright blue.'}
## plot map of species distributions
# fortify data
grid.FPLY <- spFortify(grid.PLY)
spp.grid.FPLY <- ldply(unique(spp.samples.DF$species), function(x) {
		z <- grid.FPLY[,c('long', 'lat', 'group', x),drop=FALSE]
		names(z)[4] <- 'presence'
		z$species <- gsub('\\_', ' ', x)
		return(z)
	}
)
# plot species data
ggplot() +
	geom_polygon(data=countries.FPLY, aes(x=long, y=lat, group=group),
		fill='grey20', color='grey80') +
	geom_polygon(data=spp.grid.FPLY, aes(x=long, y=lat, 
		group=group, fill=presence), alpha=0.8, color='grey10') +
	theme_classic() +
	guides(fill=guide_legend(title='Presence')) +
	theme(axis.ticks=element_blank(), axis.text=element_blank(),
		axis.line=element_blank()) +
	coord_cartesian(
		xlim=buffered.range(grid.FPLY$long, 0.05),
		ylim=buffered.range(grid.FPLY$lat, 0.05)
	) +
	xlab('') +
	ylab('') +
	facet_wrap(~ species, ncol=4)
```

```{r, fig.width=4, fig.height=3.5, fig.cap="Species richness. Squares denote planning units. Planning units with a brighter color are inhabited by more species."}
# calculate species richness
grid.PLY$Species_richness <- grid.PLY@data %>%
	select(5:(4+n.spp)) %>% as.matrix() %>% rowSums()

# plot species richness
ggplot() +
	geom_polygon(data=countries.FPLY, aes(x=long, y=lat, group=group),
		fill='grey20', color='grey80') +
	geom_polygon(data=spFortify(grid.PLY), aes(x=long, y=lat, 
		group=group, fill=Species_richness), alpha=0.8, color='grey10') +
	guides(fill=guide_legend(title='Count (#)')) +
	theme_classic() +
	theme(axis.ticks=element_blank(), axis.text=element_blank(),
		axis.line=element_blank()) +
	coord_cartesian(
		xlim=buffered.range(grid.FPLY$long, 0.05),
		ylim=buffered.range(grid.FPLY$lat, 0.05)
	) +
	xlab('') +
	ylab('') +
	ggtitle('Species richness')
```

### Appendix S2: BayeScan Results

```{r}
knitr::kable(
	format.table(
		ldply(
			seq_along(unique(spp.samples.DF$species)), 
			function(i) {
				data.frame(
					Species=paste0('\\textit{',gsub('\\_', ' ', unique(spp.samples.DF$species)[i]),'}'),
					Individuals=nrow(spp.BayeScanData.LST[[i]]@matrix),
					Total_Loci=ncol(spp.BayeScanData.LST[[i]]@matrix),
					Neutral_Loci=sum(spp.BayeScan.LST[[i]]@results@fst[[7]]=='neutral'),
					Adpative_Loci=sum(spp.BayeScan.LST[[i]]@results@fst[[7]]=='adaptive'),
					Proportion_adaptive=sum(spp.BayeScan.LST[[i]]@results@fst[[7]]=='adaptive')/ nrow(spp.BayeScan.LST[[i]]@results@fst)
				)
			}
		)
	),
	digits=2,
	col.names=c('Species','Individuals (#)', 'Total Loci (#)', 'Neutral Loci (#)', 'Adaptive Loci (#)', 'Proportion Adaptive (%)'),
	align=c('l', 'c', 'c', 'c', 'c', 'c')
)
```


```{r}
knitr::kable(
	format.table(
		ldply(
			seq_along(unique(spp.samples.DF$species)), 
			function(i) {
				data.frame(
					Species=paste0('\\textit{',gsub('\\_', ' ', unique(spp.samples.DF$species)[i]),'}'),
					Primer=spp.BayeScanData.LST[[i]]@primers,
					Probability=spp.BayeScan.LST[[i]]@results@fst[[2]],
					qval=spp.BayeScan.LST[[i]]@results@fst[[4]],
					alpha=spp.BayeScan.LST[[i]]@results@fst[[5]],
					fst=spp.BayeScan.LST[[i]]@results@fst[[6]],
					Type=spp.BayeScan.LST[[i]]@results@fst[[7]]
				)
			}
		),
		omit='Type'
	),
	digits=2,
	col.names=c('Species', 'Primer', 'Probability', 'q-value', '$\\alpha$', '$F_{ST}$', 'Type'),
	align=c('l', 'c', 'c', 'c', 'c', 'c', 'c')
)
```

### Appendix S3: Genomic MDS 
```{r}
knitr::kable(
	format.table(
		ldply(
			seq_along(unique(spp.samples.DF$species)), 
			function(i) {
				ldply(
					seq_along(spp.mds.LST[[i]]),
					function(j) {
					data.frame(
						Species=paste0('\\textit{',gsub('\\_', ' ', unique(spp.samples.DF$species)[i]),'}'),
						Loci=names(spp.mds.LST[[i]])[j],
						Stress=spp.mds.LST[[i]][[j]]$stress,
						Converged=spp.mds.LST[[i]][[j]]$converged
					)
				})
			}
		),
		omit='Converged'
	),
	digits=2,
	caption='Summary of non-metric multi-dimensional scaling (MDS) analyses on genetic variation for each species.',
	col.names=c('Species', 'Loci Type', 'NMDS Stress', 'Converged'),
	align=c('l', 'c', 'c', 'c')
)
```

### Appendix S4: Distribution maps of intra-specific variation
```{r}
plot.spp.mds <- function(i) {
	do.call(
		grid.arrange,
		append(
			unlist(llply(c('adaptive','neutral'), function(g) {
				llply(seq_len(mds.k), function(k) {
					ggplot() +
						geom_polygon(data=countries.FPLY, aes(x=long, y=lat, group=group),
							fill='grey20', color='grey80') +
						geom_polygon(data=grid.FPLY, aes_string(x='long', y='lat', 
							group='group', fill=paste0(unique(spp.samples.DF$species)[i], '_', j, '_d',k)),
							alpha=0.8, color='grey10') +
						guides(fill=guide_legend(title=' ')) +
						theme_classic() +
						theme(axis.ticks=element_blank(), axis.text=element_blank(),
							plot.margin=unit(c(0,0,0,0),'cm'), axis.line=element_blank()) +
						coord_cartesian(
							xlim=buffered.range(grid.FPLY$long, 0.05),
							ylim=buffered.range(grid.FPLY$lat, 0.05)
						) +
						xlab('') +
						ylab('') +
						ggtitle(paste0(g,' (',k,')'))
				})
			}),recursive=FALSE),
			list(ncol=2)
		)
	)
}
```

```{r, fig.width=6.5, fig.height=4.5, fig.cap=paste0('Distribution of adaptive and neutral genetic variation in \\textit{',gsub('\\_', ' ', unique(spp.samples.DF$species)[1]),'}. Each square represents a planning unit. The color of each planning unit panel corresponds to ordination values. Planning units with similar colors contain individiduals with similar genetic variation.')}
plot.spp.mds(1)
```

```{r, fig.width=6.5, fig.height=4.5, fig.cap=paste0('Distribution of adaptive and neutral genetic variation in \\textit{',gsub('\\_', ' ', unique(spp.samples.DF$species)[2]),'}. See Figure XX caption for conventions.')}
plot.spp.mds(2)
```

```{r, fig.width=6.5, fig.height=4.5, fig.cap=paste0('Distribution of adaptive and neutral genetic variation in \\textit{',gsub('\\_', ' ', unique(spp.samples.DF$species)[3]),'}. See Figure XX caption for conventions.')}
plot.spp.mds(3)
```

### Appendix S5: Principle components analysis on climatic variation
```{r}
## load pca summary
pca.DF <- read.table('extdata/BioClim_variables/pca.TXT', skip=80) %>% `names<-`(
	c('Principle Component', 'Eigen Value', 'Variation explained (%)',
	'Accumulative variation explained (%)')
)
## make results table showing Eigen values
knitr::kable(
	pca.DF,
	digits=2,
	caption='Summary of priciniple components analysis (PCA) on bioclimatic variation across the study area. The first two principle components (PCs) were used for subsequent analysis.',
	align=c('l', 'c', 'c', 'c')
)
```

### Appendix S6: Maps of climatic variation
```{r, width=6.5, height=4.5, fig.cap='Climatic variation. Each panel depicts variation based on a different principle component (PC). Sqaures represent planning units. The color of each planning unit denotes the average priciniple component value of pixels inside it. Planning units with more similar colors have more similar climates regimes.'}
do.call(
	grid.arrange,
		append(
		llply(grep('^env\\_.*$', names(grid.DF), value=TRUE), function(x) {
			ggplot() +
				geom_polygon(data=countries.FPLY, aes(x=long, y=lat, group=group),
					fill='grey20', color='grey80') +
				geom_polygon(data=grid.FPLY, aes_string(x='long', y='lat', 
					group='group', fill=x),
					alpha=0.8, color='grey10') +
				guides(fill=guide_legend(title=' ')) +
				theme_classic() +
				theme(axis.ticks=element_blank(), axis.text=element_blank(),
					plot.margin=unit(c(0,0,0,0),'cm'), axis.line=element_blank()) +
				coord_cartesian(
					xlim=buffered.range(grid.FPLY$long, 0.05),
					ylim=buffered.range(grid.FPLY$lat, 0.05)
				) +
				xlab('') +
				ylab('') +
				ggtitle(paste0('PC ', substr(x, nchar(x), nchar(x))))
		}),
		list(ncol=2)
	)
)
```


```{r, include=FALSE}
# save vignette's global.env 
save.image('extdata/Results_cache/vignette.rda')
```
