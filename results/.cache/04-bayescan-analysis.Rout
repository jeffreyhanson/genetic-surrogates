
R version 3.2.2 (2015-08-14) -- "Fire Safety"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

Revolution R Open 3.2.2
The enhanced R distribution from Revolution Analytics
[Previously saved workspace restored]

> ## load .rda
> session::restore.session('results/.cache/03-stucture-analysis.rda')
Loading all data...
Loading packages...

Attaching package: ‘dplyr’

The following objects are masked from ‘package:plyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following objects are masked from ‘package:data.table’:

    between, last

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

This is vegan 2.3-2
rgeos version: 0.3-15, (SVN revision 515)
 GEOS runtime version: 3.4.2-CAPI-1.8.2 r3921 
 Linking to sp version: 1.2-1 
 Polygon checking: TRUE 


Attaching package: ‘snow’

The following objects are masked from ‘package:parallel’:

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, clusterSplit, makeCluster, parApply,
    parCapply, parLapply, parRapply, parSapply, splitIndices,
    stopCluster

rgdal: version: 1.1-1, (SVN revision 572)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.10.1, released 2013/08/26
 Path to GDAL shared files: /usr/share/gdal/1.10
 Loaded PROJ.4 runtime: Rel. 4.8.0, 6 March 2012, [PJ_VERSION: 480]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.2-1 

Attaching package: ‘raster’

The following object is masked _by_ ‘.GlobalEnv’:

    select

The following object is masked from ‘package:tidyr’:

    extract

The following object is masked from ‘package:dplyr’:

    select

The following object is masked from ‘package:data.table’:

    shift


Attaching package: ‘structurer’

The following objects are masked from ‘package:bayescanr’:

    loci.subset, n.loci, n.pop, n.samples, sample.subset

Restoring search path...
Done.
> 
> # subset out loci with polymorphisms that have really low or really high frequency
> spp.BayeScanData.sample.loci.subset.LST <- llply(
+ 	spp.BayeScanData.sample.subset.LST,
+ 	function(x) {
+ 		freqs <- colMeans(x@matrix)
+ 		valid.loci <- which(freqs <= 1-(bs.freq) | freqs >= bs.freq)
+ 		return(bayescanr:::loci.subset(x, valid.loci))
+ 	}
+ )
> 
> # run BayeScan over subsetted objects
> spp.BayeScan.sample.loci.subset.LST <- llply(
+ 	spp.BayeScanData.sample.loci.subset.LST,
+ 	run.BayeScan,
+ 	fdr=bs.fdr,
+ 	threads=bs.threads,
+ 	n=bs.n,
+ 	thin=bs.thin,
+ 	nbp=bs.nbp,
+ 	pilot=bs.pilot,
+ 	burn=bs.burn
+ )
Using 1 threads (2 cpu detected on this machine)
Pilot runs...
11% 22% 33% 44% 55% 66% 77% 88% 
Calculation...
2% 4% 6% 8% 10% 12% 14% 16% 18% 20% 22% 24% 26% 28% 30% 32% 34% 36% 38% 40% 42% 44% 46% 48% 50% 52% 54% 56% 58% 60% 62% 64% 66% 68% 70% 72% 74% 76% 78% 80% 82% 84% 86% 88% 90% 92% 94% 96% 98% 
Using 1 threads (2 cpu detected on this machine)
Pilot runs...
11% 22% 33% 44% 55% 66% 77% 88% 
Calculation...
2% 4% 6% 8% 10% 12% 14% 16% 18% 20% 22% 24% 26% 28% 30% 32% 34% 36% 38% 40% 42% 44% 46% 48% 50% 52% 54% 56% 58% 60% 62% 64% 66% 68% 70% 72% 74% 76% 78% 80% 82% 84% 86% 88% 90% 92% 94% 96% 98% 
Using 1 threads (2 cpu detected on this machine)
Pilot runs...
11% 22% 33% 44% 55% 66% 77% 88% 
Calculation...
2% 4% 6% 8% 10% 12% 14% 16% 18% 20% 22% 24% 26% 28% 30% 32% 34% 36% 38% 40% 42% 44% 46% 48% 50% 52% 54% 56% 58% 60% 62% 64% 66% 68% 70% 72% 74% 76% 78% 80% 82% 84% 86% 88% 90% 92% 94% 96% 98% 
Using 1 threads (2 cpu detected on this machine)
Pilot runs...
11% 22% 33% 44% 55% 66% 77% 88% 
Calculation...
2% 4% 6% 8% 10% 12% 14% 16% 18% 20% 22% 24% 26% 28% 30% 32% 34% 36% 38% 40% 42% 44% 46% 48% 50% 52% 54% 56% 58% 60% 62% 64% 66% 68% 70% 72% 74% 76% 78% 80% 82% 84% 86% 88% 90% 92% 94% 96% 98% 
Using 1 threads (2 cpu detected on this machine)
Pilot runs...
11% 22% 33% 44% 55% 66% 77% 88% 
Calculation...
2% 4% 6% 8% 10% 12% 14% 16% 18% 20% 22% 24% 26% 28% 30% 32% 34% 36% 38% 40% 42% 44% 46% 48% 50% 52% 54% 56% 58% 60% 62% 64% 66% 68% 70% 72% 74% 76% 78% 80% 82% 84% 86% 88% 90% 92% 94% 96% 98% 
Using 1 threads (2 cpu detected on this machine)
Pilot runs...
11% 22% 33% 44% 55% 66% 77% 88% 
Calculation...
2% 4% 6% 8% 10% 12% 14% 16% 18% 20% 22% 24% 26% 28% 30% 32% 34% 36% 38% 40% 42% 44% 46% 48% 50% 52% 54% 56% 58% 60% 62% 64% 66% 68% 70% 72% 74% 76% 78% 80% 82% 84% 86% 88% 90% 92% 94% 96% 98% 
Using 1 threads (2 cpu detected on this machine)
Pilot runs...
11% 22% 33% 44% 55% 66% 77% 88% 
Calculation...
2% 4% 6% 8% 10% 12% 14% 16% 18% 20% 22% 24% 26% 28% 30% 32% 34% 36% 38% 40% 42% 44% 46% 48% 50% 52% 54% 56% 58% 60% 62% 64% 66% 68% 70% 72% 74% 76% 78% 80% 82% 84% 86% 88% 90% 92% 94% 96% 98% 
Using 1 threads (2 cpu detected on this machine)
Pilot runs...
11% 22% 33% 44% 55% 66% 77% 88% 
Calculation...
2% 4% 6% 8% 10% 12% 14% 16% 18% 20% 22% 24% 26% 28% 30% 32% 34% 36% 38% 40% 42% 44% 46% 48% 50% 52% 54% 56% 58% 60% 62% 64% 66% 68% 70% 72% 74% 76% 78% 80% 82% 84% 86% 88% 90% 92% 94% 96% 98% 
Using 1 threads (2 cpu detected on this machine)
Pilot runs...
11% 22% 33% 44% 55% 66% 77% 88% 
Calculation...
2% 4% 6% 8% 10% 12% 14% 16% 18% 20% 22% 24% 26% 28% 30% 32% 34% 36% 38% 40% 42% 44% 46% 48% 50% 52% 54% 56% 58% 60% 62% 64% 66% 68% 70% 72% 74% 76% 78% 80% 82% 84% 86% 88% 90% 92% 94% 96% 98% 
> 
> # run mds
> spp.mds.LST <- llply(
+ 	seq_along(spp.BayeScanData.LST),
+ 	.fun=function(i) {
+ 		# subset loci for species
+ 		curr.spp <- bayescanr:::loci.subset(
+ 			spp.BayeScanData.LST[[i]],
+ 			which(spp.BayeScanData.LST[[i]]@primers %in% spp.BayeScan.sample.loci.subset.LST[[i]]@data@primers)
+ 		)
+ 		# manually classify loci as neutral or adaptive
+ 		curr.spp.type <- replace(
+ 			rep('neutral', bayescanr:::n.loci(curr.spp)),
+ 			spp.BayeScan.sample.loci.subset.LST[[i]]@results@summary$type=='adaptive',
+ 			'adaptive'
+ 		)
+ 		# run mds over neutral and/or adaptive loci
+ 		return(`names<-`(llply(c('adaptive', 'neutral'), function(j) {
+ 			if (sum(curr.spp.type==j)==0)
+ 				return(NULL)
+ 			return(
+ 				mds(
+ 					bayescanr:::loci.subset(curr.spp, curr.spp.type==j),
+ 					metric='gower',
+ 					k=mds.k,
+ 					trymax=mds.trymax
+ 				)
+ 			)
+ 		}), c('adaptive','neutral')))
+ 	}
+ )
Run 0 stress 1.445903e-15 
Run 1 stress 0 
... New best solution
... procrustes: rmse 0.0737732  max resid 0.5227201 
Run 2 stress 0 
... procrustes: rmse 0.08237752  max resid 0.3403493 
Run 0 stress 0.2254606 
Run 1 stress 0.2193601 
... New best solution
... procrustes: rmse 0.06012011  max resid 0.3223767 
Run 2 stress 0.2331042 
Run 0 stress 0.241093 
Run 1 stress 0.2469848 
Run 2 stress 0.24668 
Run 0 stress 0.2040256 
Run 1 stress 0.2068307 
Run 2 stress 0.2116977 
Warning messages:
1: In metaMDS(comm = daisy(cbind(as.data.frame(x@matrix == 1), 1),  :
  Stress is (nearly) zero - you may have insufficient data
2: In daisy(cbind(as.data.frame(x@matrix == 1), 1), metric = metric,  :
  at least one binary variable has not 2 different levels.
3: In daisy(cbind(as.data.frame(x@matrix == 1), 1), metric = metric,  :
  at least one binary variable has not 2 different levels.
> 
> # remove NULL entries from MDS list
> 
> # store mds rotations for each sample
> spp.samples.DF <- ldply(seq_along(unique(spp.samples.DF$species)), .fun=function(i) {
+ 	x <- filter(spp.samples.DF, species==unique(spp.samples.DF$species)[i])
+ 	for (j in c('adaptive', 'neutral')) {
+ 		if (!is.null(spp.mds.LST[[i]][[j]])) {
+ 			x <- cbind(
+ 				x,
+ 				`names<-`(
+ 					as.data.frame(spp.mds.LST[[i]][[j]]$points),
+ 					paste0(j,'_d',seq_len(mds.k))
+ 				)
+ 			)
+ 		}
+ 	}
+ 	return(x)
+ })
> 
> # store mds average rotation for each grid
> for (i in seq_along(unique(spp.samples.DF$species))) {
+ 	for (j in c('adaptive', 'neutral')) {
+ 		if(!is.null(spp.mds.LST[[i]][[j]])) {
+ 			curr.sub <- filter(spp.samples.DF, species==unique(spp.samples.DF$species)[i])
+ 			for (k in seq_len(mds.k)) {
+ 				curr.vals <- tapply(
+ 					curr.sub[[paste0(j,'_d',k)]],
+ 					curr.sub$cell,
+ 					FUN=mean
+ 				)
+ 				curr.pos <- match(names(curr.vals), grid.DF$cell)
+ 				grid.DF[curr.pos,paste0(unique(spp.samples.DF$species)[i],'_',j,'_d',k)] <- curr.vals
+ 			}
+ 		}
+ 	}
+ }
> 
> # update grid.PLY with additional attributes
> grid.PLY@data <- grid.DF
> 
> ## save .rda
> save.session('results/.cache/04-bayescan-analysis.rda')
Saving search path..
Saving list of loaded packages..
Saving all data...
Done.
> 
> proc.time()
   user  system elapsed 
 27.896   0.967  28.897 
